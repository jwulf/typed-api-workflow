# Camunda 8 Public API OpenAPI Specification Standards

The Camunda 8 Public API specification is a compile-time guarantee of predictable runtime interoperability between systems that correctly implement the specification. 

It enables static reasoning about the runtime behaviour of the integrated system of the Camunda engine and customer application code.

## Camunda Keys

Marked by: 
- `x-semantic-key: true`
- `$ref: "#/components/schemas/CamundaKey"`
- `format: "<Name>"`

Example: 

```yaml
    ProcessDefinitionKey:
      allOf:
        - $ref: "#/components/schemas/CamundaKey"
        - description: "Key for a process definition. Only use values returned by\
            \ the system."
          format: "ProcessDefinitionKey"
          x-semantic-type: "ProcessDefinitionKey"
```

Camunda Keys are the system-assigned keys that identify a resource in the engine domain. 

Examples: `ProcessInstanceKey`, `DecisionDefinitionKey`. 

They have the following characteristics: 
- Canonical identifier generated and returned by an API request.
- Generated by the engine (Java long format, serialised to string).
- Non-computable on the client (must be retrieved from API).

The schema components are used by the following: 

- `$ref: "#/components/schemas/CamundaKey"`
  - SDK generation. This is used to generate types like `CamundaKey<ProcessDefinitionKey>`
  - SDK generation. Inherits the runtime validation characteristics of `CamundaKey`. 
- `format` 
  - Documentation. Generates output like `string<ProcessDefinitionKey>`
- `x-semantic-key: true`
  - SDK generation. This is used to allow non-SDK users to use primitives (raw string types) while providing SDK users with strong distinct types.

## Semantic key providers

Marked by: 
- `x-semantic-provider: true`
- `$ref: "#/components/schemas/JobKey"`

Example: 

```yaml
jobKey:
    x-semantic-provider: true
    allOf:
    - $ref: "#/components/schemas/JobKey"
    - description: "The key, a unique identifier for the job."
```

Semantic provider fields in API responses are fields that provide a semantic key, rather than just exposing it. 

The schema component is used in the following way: 

- `$ref: "#/components/schemas/JobKey"`
  - Documentation. Used to narrow the type of `string`. Generates output like `string<JobKey>`.
  - SDK generation. Produces types like `CamundaKey<JobKey>`
  - Test generation. Used to generate a dependency graph of API operations.
- `x-semantic-provider: true`
  - Test generation. Used to reason about operations that can satisfy semantic dependencies in chains.

## Non-engine provided system-assigned keys

Marked by: 
- `$ref: "#/components/schemas/CamundaKey"`
- `x-semantic-type: <type>`
- `format: "<format>"`
- `pattern: <pattern>`
- `minLength: <number>`
- `maxLength: <number>`

Example: 

```yaml
EndCursor:
allOf:
- $ref: "#/components/schemas/CamundaKey"
- description: "The end cursor in a search query result set."
    format: "base64"
    x-semantic-type: "EndCursor"
    pattern: '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$'
    minLength: 2
    maxLength: 300
    example: "WzIyNTE3OTk4MTM2ODcxMDJd"
```
These are additional non-client-computable references returned in API responses.

The schema component is used in the following way: 
- `ref: "#/components/schemas/CamundaKey"`
  - Test generation reasoning
  - SDK generation. Produces types like `CamundaKey<EndCursor>`.
- `x-semantic-type`
  - Test generation reasoning.
  - SDK generation. Produces types like `CamundaKey<EndCursor>`.
- `format`
  - Documentation. Generates output like `string<base64>`.
- `pattern`
  - Documentation. 
  - SDK generation. Generates runtime validation (and narrower types for languages that support it).
- `minLength` / `maxLength`
  - SDK generation. Overrides validation inherited from `CamundaKey`.

  ## Eventual Consistency

  Marked by: 
  - `x-eventually-consistent: true`

  Example: 

```yaml
/user-tasks/{userTaskKey}:
get:
    x-eventually-consistent: true
    tags:
    - "User task"
    operationId: "getUserTask"
    summary: "Get user task"
    description: "Get the user task by the user task key.\n"
```

Endpoints backed by eventually consistent data storage are marked with `true`. Those backed with strongly consistent storage are marked as `false`.

The schema component is used in the following way: 
- `x-eventually-consistent: true`
  - SDK generation. Adds documentation to the developer IDE and enables SDK ergonomics and static analysis of customer applications for race condition resiliency.
  - Documentation. Adds a note that the endpoint is eventually consistent.
- `x-eventually-consistent: false`
  - Documentation. Adds a note that the endpoint is strongly consistent.

  ## Operation Kind

Recommendation on x-operation-kind:

Core enum (keep minimal, expressive):

query (pure read/search, safe)
create (new resource, not idempotent unless natural key)
update (PUT full replace, idempotent)
patch (partial mutate, not guaranteed idempotent)
delete (idempotent)
command (state transition / process action, not idempotent)
event (fire-and-forget notification; may fan out)
batchCommand (large async or multi-item command) (You can alias search to query; no separate kind needed.)
Why not collapse further:

Differentiating create vs command drives client retry & eventual consistency handling (e.g. replay-safe only if idempotent).
batchCommand flags higher latency / polling patterns.
Derived flags (auto, overrideable):

safe: true only for query
idempotent: true for query, update, delete; false otherwise unless overridden
eventual: keep existing x-eventually-consistent (orthogonal)
Spec shape: 
x-operation: 
  kind: command 
  idempotent: false # optional override 
  safe: false # optional (derived) 


Mapping examples (from your spec):

search* → query
get* → query
create*, *publication, *deployment, *user (initial setup) → create
update*, set*, put variable updates → update (or patch if partial)
activateJobs, completeJob, failJob, throwJobError, resolveIncident, publishMessage, correlateMessage, broadcastSignal, cancel*, modify*, migrate*, assign*/unassign*, evaluateDecision → command
batch operation control (suspend/resume/cancel) → command (or batchCommand if you want special handling)
delete* (explicit deletion endpoints or POST /resources/{key}/deletion) → delete (even if POST wrapper; semantic override clarifies)
Edge cases:

POST endpoints that delete (e.g. /resources/{resourceKey}/deletion): mark kind: delete to reflect semantics.
Evaluate decision (no durable state) could be command but with idempotent: true (or introduce compute if you prefer; optional).
Lint rules:

Require x-operation.kind.
Warn if HTTP verb inconsistent (e.g. GET with kind != query).
Warn if POST with kind=create but 200 w/o Location/identifier (maybe should be command or query).
Warn if update kind but non-idempotent flagged.
Adoption steps:

Add extension keys progressively.
Generator consumes explicit; falls back to heuristic only if missing (with warning).
After coverage >90%, enforce presence.


---
Semantics of DeployResource (idempotent if not new resource, otherwise idempotent)